name: GTRPGM Rule Engine CI/CD

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: gtrpgm/rule-engine

jobs:
  build-and-test:
    runs-on: ubuntu-22.04
    env:
      DB_USER: ${{ secrets.DB_USER }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
      DB_PORT: ${{ secrets.DB_PORT }}
      DB_NAME: ${{ secrets.DB_NAME }}
      REDIS_PORT: ${{ secrets.REDIS_PORT }}
      REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
      APP_HOST: "127.0.0.1"
      APP_PORT: ${{ secrets.APP_PORT }}
      WEB_PORT: ${{ secrets.WEB_PORT }}
      LANGCHAIN_GATEWAY_PORT: ${{ secrets.LANGCHAIN_GATEWAY_PORT }}
      APP_ENV: "local"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install uv
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          enable-cache: true

      - name: Set up Python 3.11
        run: uv python install 3.11

      - name: Install dependencies
        run: uv sync

      - name: Check DB Connection
        run: |
          export PYTHONPATH=$PYTHONPATH:.
          uv run python -c "from src.configs.database import check_db_connection; check_db_connection()"

      - name: Check Redis Connection
        run: |
          export PYTHONPATH=$PYTHONPATH:.
          uv run python -c "from src.configs.redis_conn import check_redis_connection; check_redis_connection()"

      - name: Server Smoke Test (Health Check)
        run: |
          export PYTHONPATH=$PYTHONPATH:.
          # 1. 서버 실행 (reload 모드 없이 실행하는 것을 권장)
          uv run python src/main.py > test_server.log 2>&1 &

          # 2. 서버가 응답할 때까지 대기 (최대 10번 시도)
          echo "Waiting for server to start..."
          for i in {1..10}; do
            if curl -s http://127.0.0.1:$APP_PORT/ > /dev/null; then
              echo "✅ Server is up and running!"
              pkill -f "python src/main.py" || true
              exit 0
            fi
            echo "Attempt $i: Server not ready yet... (waiting 3s)"
            sleep 3
          done

          # 3. 10번 시도 후에도 안 되면 실패 처리
          echo "❌ 서버 응답 테스트 실패. 로그를 출력합니다:"
          cat test_server.log
          exit 1

  build-docker-image:
    needs: build-and-test
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          build-args: |
            APP_PORT=${{ secrets.APP_PORT }}

  deploy:
    needs: build-docker-image
    runs-on: ubuntu-22.04
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Deploy via SSH
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.REMOTE_HOST }}
          username: ${{ secrets.REMOTE_USERNAME }}
          key: ${{ secrets.REMOTE_SSH_KEY }}
          script: |
            # 1. GHCR 로그인 (서버에서 이미지를 받아오기 위함)
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # 2. 최신 이미지 Pull (빌드가 아니므로 리소스 소모가 매우 적음)
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

            # 3. 기존 컨테이너 정리 (필요한 경우에만 중지/삭제)
            if [ "$(docker ps -aq -f name=rule-engine)" ]; then
                echo "Stopping and removing existing container..."
                docker stop rule-engine || true
                docker rm rule-engine || true
            fi

            # 4. 새 컨테이너 실행
            docker run -d \
              --name rule-engine \
              -p ${{ secrets.APP_PORT }}:${{ secrets.APP_PORT }} \
              --restart unless-stopped \
              -e DB_USER=${{ secrets.DB_USER }} \
              -e DB_PASSWORD=${{ secrets.DB_PASSWORD }} \
              -e REMOTE_HOST=${{ secrets.REMOTE_HOST }} \
              -e DB_PORT=${{ secrets.DB_PORT }} \
              -e DB_NAME=${{ secrets.DB_NAME }} \
              -e REDIS_PORT=${{ secrets.REDIS_PORT }} \
              -e REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }} \
              -e APP_PORT=${{ secrets.APP_PORT }} \
              -e WEB_PORT=${{ secrets.WEB_PORT }} \
              -e LANGCHAIN_GATEWAY_PORT=${{ secrets.LANGCHAIN_GATEWAY_PORT }} \
              -e APP_ENV=prod \
              ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

            # 5. 사용하지 않는 오래된 이미지 정리 (디스크 용량 확보)
            docker image prune -f
